[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FastMigrate",
    "section": "",
    "text": "The fastmigrate library helps with structured migration of data in SQLite. That is, it gives you a way to specify and run a sequence of updates to your database schema, while preserving user data.\n\n\nfastmigrate is available to install from pypi.\npip install fastmigrate\n\n# or if using uv add it to your pyproject.toml\nuv add fastmigrate\nTo run all the tests, you also need to install the sqlite3 executable on your system.\n\n\n\nOnce you have added a migrations/ directory to your app, you would typically use fastmigrate in your application code like so:\nfrom fastmigrate.core import create_db, run_migrations\n\n# At application startup:\ndb_path = \"path/to/database.db\"\nmigrations_dir = \"path/to/migrations\"\n\n# Create/verify there is a versioned database, or else fail\ncurrent_version = create_db(db_path)\n\n# Apply any pending migrations\nsuccess = run_migrations(db_path, migrations_dir, verbose=False)\nif not success:\n    # Handle migration failure\n    print(\"Database migration failed!\")\nThis will create a db if needed. Then, fastmigrate will detect every validly-named migration script in the migrations directory, select the ones with version numbers greater than the current db version number, and run the migration in alphabetical order, updating the db’s version number as it proceeds, stopping if any migration fails.\nThis will guarantee that all subsequent code will encounter a database at the schema version defined by your highest-numbered migration script. So when you deploy updates to your app, those updates should include any new migration scripts along with modifications to code, which should now expect the new db schema.\nIf you get the idea and are just looking for a reminder about a reasonable workflow for safely adding a new migration please see this note on safely adding migrations\n\n\n\nFastmigrate implements the standard database migration pattern, so these key concepts may be familiar.\n\nthe version number of a database:\n\nthis is an int value stored in a single-row table _meta in the field version. This is “db version”, which is also the version of the last migration script which was run on that database.\n\nthe migrations directory contains the migration scripts, which initialize the db to its initial version 1 and update it to the latest version as needed.\nevery valid migration script must:\n\nconform to the “fastmigrate naming rule”\nbe one of the following:\n\na .py or .sh file. In this case, fastmigrate will execute the file, pass the path to the db as the first positional argument. Fastmigrate will interpret a non-zero exit code as failure.\na .sql file. In this case, fastmigrate will execute the SQL script against the database.\n\nterminate with an exit code of 0, if and only if it succeeds\n(ideally) leave the db unmodified, if it fails\n\nthe fastmigrate naming rule is that every migration script match this naming pattern: [index]-[description].[fileExtension], where [index] must be a string representing 4-digit integer. This naming convention defines the order in which scripts will run and the db version each migration script produces.\nattempting a migration is:\n\ndetermining the current version of a database\ndetermining if there are any migration scripts with versions higher than the db version\ntrying to run those scripts\n\n\n\n\n\nThe point of the system is that if you adopt it, fastmigrate offers the following two guarantees:\n\n[!NOTE] Fastmigrate will never leave a database marked with an incorrect version without signalling an error, if your migration scripts reliably exit with an error code whenever they fail.\nFurthermore, fastmigrate will never leave a database corrupted, if your migration scripts always leave the db unmodified when they fail. (This is relatively easy with sql-based scripts, since they can use sql rollback).\n\nTo get these guarantees, you only need to use fastmigrate’s public commands and APIs to handle creating the db and running migrations (unless you are enrolling an existing db).\nOne easy way to experiment with these core operations, for instance when testing a new migration, is via the command line tool.\n\n\n\nWhen you run fastmigrate, it will look for migration scripts in ./migrations/ and a database at ./data/database.db. These values can also be overridden by CLI arguments or by values set in the .fastmigrate configuration file, which is in ini format. But you can also provide them as with the command line arguments --db and --migrations.\nHere are some commands:\n\nCreate Database:\nfastmigrate_create_db --db /path/to/data.db\nIf no database is there, create an empty database with version=0. If a versioned db is there, do nothing. If an unversioned db or anything else is there, exit with an error code. This is equivalent to calling fastmigrate.create_db()\nCheck a db\nfastmigrate_check_version --db /path/to/data.db\nThis will report the version of both fastmigrate and the db.\nBackup a db:\nfastmigrate_backup_db --db /path/to/data.db\nBackup the database with a timestamped filename ending with a .backup extention. This is equivalent to calling fastmigrate.backup_db()\nRun migrations:\nfastmigrate_run_migrations --db path/to/data.db\nRun all needed migrations on the db. Fails if a migration fails, or if there is no managed db at the path. This is equivalent to calling fastmigrate.run_migrations()\n\n\n\n\nFastMigrate needs to manage database versioning in order to run migrations.\nSo if you already have a database which was created outside of fastmigrate, then you need to enroll it.\nPlease see the dedicated note on enrolling an existing db.\n\n\n\n\nUnversioned Databases: FastMigrate will refuse to run migrations on existing databases that don’t have a _meta table with version information.\nSequential Execution: Migrations are executed in order based on their index numbers. If migration #3 fails, migrations #1-2 remain applied and the process stops.\nVersion Integrity: The database version is only updated after a migration is successfully completed.\nExternal Side Effects: Python and Shell scripts may have side effects outside the database (file operations, network calls) that are not managed by fastmigrate.\nDatabase Locking: During migration, the database may be locked. Applications should not attempt to access it while migrations are running.\nBackups: For safety, you can use the --backup option to create a backup before running migrations.\n\n\n\n\nTo contribute to fastmigrate, create an editable install with the dev dependency group using your favorite package manager.\nFor example, with uv (preferred):\nuv sync\nor with pip 25.1:\npip install -e . --group dev\nWe currently don’t check in the uv.lock file."
  },
  {
    "objectID": "index.html#fastmigrate",
    "href": "index.html#fastmigrate",
    "title": "FastMigrate",
    "section": "",
    "text": "The fastmigrate library helps with structured migration of data in SQLite. That is, it gives you a way to specify and run a sequence of updates to your database schema, while preserving user data.\n\n\nfastmigrate is available to install from pypi.\npip install fastmigrate\n\n# or if using uv add it to your pyproject.toml\nuv add fastmigrate\nTo run all the tests, you also need to install the sqlite3 executable on your system.\n\n\n\nOnce you have added a migrations/ directory to your app, you would typically use fastmigrate in your application code like so:\nfrom fastmigrate.core import create_db, run_migrations\n\n# At application startup:\ndb_path = \"path/to/database.db\"\nmigrations_dir = \"path/to/migrations\"\n\n# Create/verify there is a versioned database, or else fail\ncurrent_version = create_db(db_path)\n\n# Apply any pending migrations\nsuccess = run_migrations(db_path, migrations_dir, verbose=False)\nif not success:\n    # Handle migration failure\n    print(\"Database migration failed!\")\nThis will create a db if needed. Then, fastmigrate will detect every validly-named migration script in the migrations directory, select the ones with version numbers greater than the current db version number, and run the migration in alphabetical order, updating the db’s version number as it proceeds, stopping if any migration fails.\nThis will guarantee that all subsequent code will encounter a database at the schema version defined by your highest-numbered migration script. So when you deploy updates to your app, those updates should include any new migration scripts along with modifications to code, which should now expect the new db schema.\nIf you get the idea and are just looking for a reminder about a reasonable workflow for safely adding a new migration please see this note on safely adding migrations\n\n\n\nFastmigrate implements the standard database migration pattern, so these key concepts may be familiar.\n\nthe version number of a database:\n\nthis is an int value stored in a single-row table _meta in the field version. This is “db version”, which is also the version of the last migration script which was run on that database.\n\nthe migrations directory contains the migration scripts, which initialize the db to its initial version 1 and update it to the latest version as needed.\nevery valid migration script must:\n\nconform to the “fastmigrate naming rule”\nbe one of the following:\n\na .py or .sh file. In this case, fastmigrate will execute the file, pass the path to the db as the first positional argument. Fastmigrate will interpret a non-zero exit code as failure.\na .sql file. In this case, fastmigrate will execute the SQL script against the database.\n\nterminate with an exit code of 0, if and only if it succeeds\n(ideally) leave the db unmodified, if it fails\n\nthe fastmigrate naming rule is that every migration script match this naming pattern: [index]-[description].[fileExtension], where [index] must be a string representing 4-digit integer. This naming convention defines the order in which scripts will run and the db version each migration script produces.\nattempting a migration is:\n\ndetermining the current version of a database\ndetermining if there are any migration scripts with versions higher than the db version\ntrying to run those scripts\n\n\n\n\n\nThe point of the system is that if you adopt it, fastmigrate offers the following two guarantees:\n\n[!NOTE] Fastmigrate will never leave a database marked with an incorrect version without signalling an error, if your migration scripts reliably exit with an error code whenever they fail.\nFurthermore, fastmigrate will never leave a database corrupted, if your migration scripts always leave the db unmodified when they fail. (This is relatively easy with sql-based scripts, since they can use sql rollback).\n\nTo get these guarantees, you only need to use fastmigrate’s public commands and APIs to handle creating the db and running migrations (unless you are enrolling an existing db).\nOne easy way to experiment with these core operations, for instance when testing a new migration, is via the command line tool.\n\n\n\nWhen you run fastmigrate, it will look for migration scripts in ./migrations/ and a database at ./data/database.db. These values can also be overridden by CLI arguments or by values set in the .fastmigrate configuration file, which is in ini format. But you can also provide them as with the command line arguments --db and --migrations.\nHere are some commands:\n\nCreate Database:\nfastmigrate_create_db --db /path/to/data.db\nIf no database is there, create an empty database with version=0. If a versioned db is there, do nothing. If an unversioned db or anything else is there, exit with an error code. This is equivalent to calling fastmigrate.create_db()\nCheck a db\nfastmigrate_check_version --db /path/to/data.db\nThis will report the version of both fastmigrate and the db.\nBackup a db:\nfastmigrate_backup_db --db /path/to/data.db\nBackup the database with a timestamped filename ending with a .backup extention. This is equivalent to calling fastmigrate.backup_db()\nRun migrations:\nfastmigrate_run_migrations --db path/to/data.db\nRun all needed migrations on the db. Fails if a migration fails, or if there is no managed db at the path. This is equivalent to calling fastmigrate.run_migrations()\n\n\n\n\nFastMigrate needs to manage database versioning in order to run migrations.\nSo if you already have a database which was created outside of fastmigrate, then you need to enroll it.\nPlease see the dedicated note on enrolling an existing db.\n\n\n\n\nUnversioned Databases: FastMigrate will refuse to run migrations on existing databases that don’t have a _meta table with version information.\nSequential Execution: Migrations are executed in order based on their index numbers. If migration #3 fails, migrations #1-2 remain applied and the process stops.\nVersion Integrity: The database version is only updated after a migration is successfully completed.\nExternal Side Effects: Python and Shell scripts may have side effects outside the database (file operations, network calls) that are not managed by fastmigrate.\nDatabase Locking: During migration, the database may be locked. Applications should not attempt to access it while migrations are running.\nBackups: For safety, you can use the --backup option to create a backup before running migrations.\n\n\n\n\nTo contribute to fastmigrate, create an editable install with the dev dependency group using your favorite package manager.\nFor example, with uv (preferred):\nuv sync\nor with pip 25.1:\npip install -e . --group dev\nWe currently don’t check in the uv.lock file."
  },
  {
    "objectID": "enrolling.html",
    "href": "enrolling.html",
    "title": "Enrolling an existing db",
    "section": "",
    "text": "If you use fastmigrate with valid migration scripts, fastmigrate can guarantee the version of your database presented to your application code. This is the value of managed migrations.\nHowever, to provide this guarantee, you need your database to be managed by fastmigrate. If you created the database with fastmigrate (using create_db or the fastmigrate_create_db CLI command), then it is managed.\nBut what if you are starting with an application built outside of fastmigrate, and you want to enroll the database in fastmigrate? Here is how to think about it, and how to do it correctly:\nTo clarify the background: the key invariant which we need to maintain is this: any database which has a fastmigrate version number (like 1, or like 3) is exactly in the state which would be produced by the migration script with that version number (like by 0001-initialize.sql or 0003-unify-users.sql).\nNow if you create a db with fastmigrate, it is created with version 0, and the version only advances as a result of running migration scripts. So this maintains the invariant.\nBut if you are enrolling an existing db into fastmigrate, then you need to do three things.\n\nFirst, write a migration script 0001-initialize.sql which will produce the schema of the database which you are working with right now.\nWhy? You need this so that, when you are starting fresh instances of your application, fastmigrate can create a database which is equivalent to what you have created now. The easiest way to create this script is to run sqlite3 data.db .schema &gt; 0001-initialize.sql on your current database, which will create a sql file 0001-initialize.sql which creates a fresh db with the same schema as your current db.\nThis is now your first migration script. Because it matches the current state of your current database, it will not be run on your current database. But it will ensure that newly created databases match your current database.\nFrom an abundance of caution, you should use it to create a db and confirm that it is indeed equivalent to your current db.\nSecond, manually modify your current data to add fastmigrate version tag and set its version to 1. You can do this by using fastmigrate’s internal API. Doing this constitutes asserting that the db is in fact in the state which would be produced by the migration script 0001. After doing this, fastmigrate will recognize your db as managed. Here is how to do it:\n\nfrom fastmigrate.core import _ensure_meta_table, _set_db_version\n_ensure_meta_table(\"path/to/data.db\")\n_set_db_version(\"path/to/data.db\",1)\n\nThird, update your application code.\nYou should update it so that it no longer manually creates and initializes a database if it is missing by itself (as it might do now), but instead uses fastmigrate to create the db and to run the migrations, as is shown in the readme. You should check the migration scripts into version control alongside your application code. Your application code should now all be written under the assumption that it will find the database in the state defined by the highest-numbered migration script in the repo.",
    "crumbs": [
      "Enrolling an existing db"
    ]
  },
  {
    "objectID": "adding_migrations.html",
    "href": "adding_migrations.html",
    "title": "Add a new migration",
    "section": "",
    "text": "So you need to modify your db schema? And you want to be very sure you are doing it correctly?\nThis page is a suggested workflow to remind you how to go about this process, assuming your application is already using fastmigrate.\n\nWhat should already be in your app\nIf your app is using fastmigrate, then two things should already be in your codebase.\nFirst, there will be a migrations directory, which contains migration scripts numbered like 0001-initialize.sql, 0002-next-thing.py, 0003-another-thing.sql, and so on, all the way up to 0010-latest-thing.sql (for instance).\nSecond, your app will either have initialization code which looks a bit like this:\nfrom fastmigrate.core import create_db, run_migrations\ndb_path = \"path/to/data.db\"\nmigrations_dir = \"path/to/migrations/\"\ncurrent_version = create_db(db_path)\nsuccess = run_migrations(db_path, migrations_dir, verbose=False)\nif not success:\n    # Handle migration failure\n    print(\"Database migration failed!\")\nOr you are relying on the fastmigrate command line tool to do this for you, in which case you will have a command like this in your deployment script:\nfastmigrate_create_db --db /path/to/data.db\nfastmigrate_backup_db --db /path/to/data.db\nfastmigrate_run_migrations --migrations /path/to/migrations/ --db /path/to/data.db\nTo recap, what is going on here is that the highest-numbered migration script (0010-latest-thing.sql in this example), defines the guaranteed version of your database. The initialization code is what enforces that guarantee. After the initialization code has run successfully, the rest of your app can and should assume that your database is at version 10.\n\n\nWhat to add to your app\nSo what does this imply about adding a new migration?\nSuppose that you want to change your db schema, so that it does “one more thing”. This defines a next version of your database. Since the current version of your db is 10, the next version of your database will be 11.\n\nSo the first thing you should do is write the migration script which updates your database from its current version to the next version, as a file named 0011-one-more-thing.py (or .sql or .sh).\nThe second thing you should do is update all of your application code so that it now expects to see version 11 of your database. That is, all the code which runs after the init code should assume migration has taken place. It does not need conditional paths to handle the older version, version 10, because the fastmigrate initialization code is responsible for running the migration script if necessary, and it will have succeeded or explicitly failed.\n\nThose two changes you made – adding a new migration script, and updating your application code – should ideally be added to your version control with the same commit since they are coordinated changes. There will never come a moment when you want code which expects version 10 to see a database at version 11, nor a moment when you want code which expects version 11 to see a database at version 10. So it is unwise to check in these changes separately.\n\nNote: if you add a .sql migration script, you need have the sqlite3 binary installed on your system.\n\n\n\nHow to test\nOf course, test your application locally before pushing or deploying.\nHow? In addition to normal application testing, you might want to test your migration script in isolation from your application code. The easiest way to do that is by using the fastmigrate command line tool. If you run fastmigrate_run_migrations /path/to/migrations --db /path/to/data.db, with data.db at version 10 and an 0011 script in migrations/, then it will update the data to version 11 in isolation. You can then manually inspect the migrated database using sqlite3 or any other tool of your choice.\nThe fundamental rule to keep in mind with migrations is that you only ever add an additional migration. You never go back and change old ones. You could say the collection of migrations is append only. This is what makes them reliable, because it is what guarantees that they are always working from a known state. But it is also what can make the workflow for adding a new migration unfamiliar, since you need to think in terms of the diffs to the database, even while your application code is usually thinking in terms of the database’s instantaneous state.",
    "crumbs": [
      "Add a new migration"
    ]
  }
]