[
  {
    "objectID": "enrolling.html",
    "href": "enrolling.html",
    "title": "Enrolling an existing db",
    "section": "",
    "text": "Here’s how to add an existing db to be managed by fastmigrate.\n\nBack up your database, of course.\nRun fastmigrate_enroll_db --db /path/to/database.db against your current database.\nThis will modify your database, marking it as version 1 by adding a _meta table.\nIt will also generate an initial migration script, 0001-initialize.sql, which is for creating an empty “version 1” database with the same schema as your current database.\nMove your current database to somewhere safe, update your application’s db setup code to use fastmigrate, and run it.\nimport fastmigrate\nfastmigrate.create_db(\"/path/to/database.db\")\nfastmigrate.run_migrations(\"/path/to/database.db\")\n# application code continues from here\nSince you moved your real db, fastmigrate will create a new db at that path based on the initial migration script.\nCheck your app, to see if it is working fine.\nIf it is, your initialization script is correct, and your can move your real database back into place.\nIf not, then you will need to edit that initialization script, so that it produces a database which is equivalent to your current database.",
    "crumbs": [
      "Enrolling an existing db"
    ]
  },
  {
    "objectID": "enrolling.html#enroll-an-existing-db",
    "href": "enrolling.html#enroll-an-existing-db",
    "title": "Enrolling an existing db",
    "section": "",
    "text": "Here’s how to add an existing db to be managed by fastmigrate.\n\nBack up your database, of course.\nRun fastmigrate_enroll_db --db /path/to/database.db against your current database.\nThis will modify your database, marking it as version 1 by adding a _meta table.\nIt will also generate an initial migration script, 0001-initialize.sql, which is for creating an empty “version 1” database with the same schema as your current database.\nMove your current database to somewhere safe, update your application’s db setup code to use fastmigrate, and run it.\nimport fastmigrate\nfastmigrate.create_db(\"/path/to/database.db\")\nfastmigrate.run_migrations(\"/path/to/database.db\")\n# application code continues from here\nSince you moved your real db, fastmigrate will create a new db at that path based on the initial migration script.\nCheck your app, to see if it is working fine.\nIf it is, your initialization script is correct, and your can move your real database back into place.\nIf not, then you will need to edit that initialization script, so that it produces a database which is equivalent to your current database.",
    "crumbs": [
      "Enrolling an existing db"
    ]
  },
  {
    "objectID": "enrolling.html#the-reason-for-this-procedure",
    "href": "enrolling.html#the-reason-for-this-procedure",
    "title": "Enrolling an existing db",
    "section": "The reason for this procedure",
    "text": "The reason for this procedure\nAs long as you use fastmigrate with valid migration scripts, fastmigrate can guarantee whch version of your database it presented to your application code. This is the value of managed migrations.\nHowever, to provide this guarantee, you need your database to be managed by fastmigrate – that is, to be explicitly marked with a version, in its _meta table. If you created the database with fastmigrate (using create_db or the fastmigrate_create_db CLI command), then it is managed.\nBut what if you are starting with an application built outside of fastmigrate, and you want to enroll the database in fastmigrate?\nTo recap the basic idea of what migrations are, the fundamental guarantee which we need to maintain is this: any database which has a fastmigrate version number (like 1, or like 3) is in the state which would be produced by the migration script with that version number (like by 0001-initialize.sql or 0003-unify-users.sql).\nSo when enrolling an existing db, you need to assign a version to the db you already have. But since that version number takes its meaning from the migration script which would produce it, you also need to create a migration script which would produce a database like yours. That script is also practically useful. If you ever want to deploy a new instance of your database, or run fresh instancs for debugging, you need that initialization script to create the initial, empty state of a db for your application to use.\nfastmigrate_enroll_db is merely a helper for those tasks. It marks your database, and generates an initialization migration script.\n\nOne reason enrollment needs manual inspection\nWhy is this not 100% automatic?\nThe tool generates the migration script based on the schema of your existing database. In many cases, that is all that matters for defining the version of a database, because the schema is all that the application code depends on.\nHowever, this will not be enough if you application requires not only a particular table schema, but also certain initial data values to be present. In that case you will need to add code to your the initialization script which not only creates the necessary tables but also inserts those values.\nFor instance, if your application code merely required a user table which tracked settings, you would expect a line like this:\nCREATE TABLE user (id INTEGER, settings TEXT);\nBut if your application code also required that the database start with one row in that table, defining a user with an ID of 1 and settings which were an empty pair of brances, then you would also add a line like so:\nINSERT INTO user VALUES (1, 0, '{}');\nThis subltety is a reason why it is not strictly accurate to say migrations version exist only to track schema schema. In fact, they define versions which should track what application code expects, which likely includes versions but not only versions.",
    "crumbs": [
      "Enrolling an existing db"
    ]
  },
  {
    "objectID": "adding_migrations.html",
    "href": "adding_migrations.html",
    "title": "Add a new migration",
    "section": "",
    "text": "So you need to modify your db schema? And you want to be very sure you are doing it correctly?\nThis page is a suggested workflow to remind you how to go about this process, assuming your application is already using fastmigrate.\n\nWhat should already be in your app\nIf your app is using fastmigrate, then two things should already be in your codebase.\nFirst, there will be a migrations directory, which contains migration scripts numbered like 0001-initialize.sql, 0002-next-thing.py, 0003-another-thing.sql, and so on, all the way up to 0010-latest-thing.sql (for instance).\nSecond, your app will either have initialization code which looks a bit like this:\nfrom fastmigrate.core import create_db, run_migrations\ndb_path = \"path/to/data.db\"\nmigrations_dir = \"path/to/migrations/\"\ncurrent_version = create_db(db_path)\nsuccess = run_migrations(db_path, migrations_dir, verbose=False)\nif not success:\n    # Handle migration failure\n    print(\"Database migration failed!\")\nOr you are relying on the fastmigrate command line tool to do this for you, in which case you will have a command like this in your deployment script:\nfastmigrate_create_db --db /path/to/data.db\nfastmigrate_backup_db --db /path/to/data.db\nfastmigrate_run_migrations --migrations /path/to/migrations/ --db /path/to/data.db\nTo recap, what is going on here is that the highest-numbered migration script (0010-latest-thing.sql in this example), defines the guaranteed version of your database. The initialization code is what enforces that guarantee. After the initialization code has run successfully, the rest of your app can and should assume that your database is at version 10.\n\n\nWhat to add to your app\nSo what does this imply about adding a new migration?\nSuppose that you want to change your db schema, so that it does “one more thing”. This defines a next version of your database. Since the current version of your db is 10, the next version of your database will be 11.\n\nSo the first thing you should do is write the migration script which updates your database from its current version to the next version, as a file named 0011-one-more-thing.py (or .sql or .sh).\nThe second thing you should do is update all of your application code so that it now expects to see version 11 of your database. That is, all the code which runs after the init code should assume migration has taken place. It does not need conditional paths to handle the older version, version 10, because the fastmigrate initialization code is responsible for running the migration script if necessary, and it will have succeeded or explicitly failed.\n\nThose two changes you made – adding a new migration script, and updating your application code – should ideally be added to your version control with the same commit since they are coordinated changes. There will never come a moment when you want code which expects version 10 to see a database at version 11, nor a moment when you want code which expects version 11 to see a database at version 10. So it is unwise to check in these changes separately.\n\nNote: fastmigrate runs .sql migrations using Python’s built-in sqlite3. You only need the external sqlite3 binary if your own .sh migrations invoke it, or if you want to inspect the database from the command line.\n\n\n\nHow to test\nOf course, test your application locally before pushing or deploying.\nHow? In addition to normal application testing, you might want to test your migration script in isolation from your application code. The easiest way to do that is by using the fastmigrate command line tool. If you run fastmigrate_run_migrations /path/to/migrations --db /path/to/data.db, with data.db at version 10 and an 0011 script in migrations/, then it will update the data to version 11 in isolation. You can then manually inspect the migrated database using sqlite3 or any other tool of your choice.\nThe fundamental rule to keep in mind with migrations is that you only ever add an additional migration. You never go back and change old ones. You could say the collection of migrations is append only. This is what makes them reliable, because it is what guarantees that they are always working from a known state. But it is also what can make the workflow for adding a new migration unfamiliar, since you need to think in terms of the diffs to the database, even while your application code is usually thinking in terms of the database’s instantaneous state.",
    "crumbs": [
      "Add a new migration"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fastmigrate",
    "section": "",
    "text": "The fastmigrate library helps with structured migration of data in SQLite. That is, it gives you a way to specify and run a sequence of updates to your database schema, while preserving user data.\n\n\nfastmigrate is available to install from pypi.\npip install fastmigrate\n\n# or if using uv add it to your pyproject.toml\nuv add fastmigrate\nFastmigrate itself does not require the external sqlite3 command-line tool. If you choose to write .sh migrations that invoke sqlite3 yourself, you’ll need it installed, but .sql migrations run via Python’s built-in sqlite3.\n\n\n\nOnce you have added a migrations/ directory to your app, you would typically use fastmigrate in your application code like so:\nfrom fastmigrate import create_db, run_migrations, setup_logging\n\n# At application startup:\ndb_path = \"path/to/database.db\"\nmigrations_dir = \"path/to/migrations\"\n\n# Create/verify there is a versioned database\ncurrent_version = create_db(db_path)\n\n# Optional: enable debug logs from fastmigrate\nsetup_logging(verbose=True)\n\n# Apply any pending migrations\nif not run_migrations(db_path, migrations_dir):\n    print(\"Database migration failed!\")\nThis will create a db if needed. Then, fastmigrate will detect every validly-named migration script in the migrations directory, select the ones with version numbers greater than the current db version number, and run the migration in alphabetical order, updating the db’s version number as it proceeds, stopping if any migration fails.\nThis will guarantee that all subsequent code will encounter a database at the schema version defined by your highest-numbered migration script. So when you deploy updates to your app, those updates should include any new migration scripts along with modifications to code, which should now expect the new db schema.\nIf you get the idea and are just looking for a reminder about a reasonable workflow for safely adding a new migration please see this note on safely adding migrations\n\n\n\nFastmigrate implements the standard database migration pattern, so these key concepts may be familiar.\n\nthe version number of a database:\n\nthis is an int value stored in a single-row table _meta in the field version. This is “db version”, which is also the version of the last migration script which was run on that database.\n\nthe migrations directory contains the migration scripts, which initialize the db to its initial version 1 and update it to the latest version as needed.\nevery valid migration script must:\n\nconform to the “fastmigrate naming rule”\nbe one of the following:\n\na .py or .sh file. In this case, fastmigrate will execute the file, pass the path to the db as the first positional argument. Fastmigrate will interpret a non-zero exit code as failure.\na .sql file. In this case, fastmigrate will execute the SQL script against the database.\n\nterminate with an exit code of 0, if and only if it succeeds\n(ideally) leave the db unmodified, if it fails\n\nthe fastmigrate naming rule is that every migration script match this naming pattern: [index]-[description].[fileExtension], where [index] must be a string representing 4-digit integer. This naming convention defines the order in which scripts will run and the db version each migration script produces.\nattempting a migration is:\n\ndetermining the current version of a database\ndetermining if there are any migration scripts with versions higher than the db version\ntrying to run those scripts\n\n\nWhen Fastmigrate encounters an error, it stops. It does not attempt to roll back or reverse. Therefore, if you want to ensure your migrations are never left half-completed mid-script, add appropriate transactions inside your sql.\n\n\n\nFastmigrate is SQLite-first by default, but you can make it database-independent by providing a backend adapter at:\n&lt;your migrations dir&gt;/config.py\nWhen this file exists, :func:fastmigrate.run_migrations will:\n\nload this module dynamically\ncall your adapter hooks to:\n\ncreate the _meta table (if needed)\nread/update the version number\nexecute .sql migrations using your database driver\n\nstill run .py and .sh migrations the same way as usual (passing str(db) as the first positional argument)\n\n\n\nEach hook may be sync or async. If a hook returns an awaitable/coroutine, fastmigrate will automatically await it.\ndef get_connection(db): ...\ndef ensure_meta_table(conn): ...\ndef get_version(conn) -&gt; int: ...\ndef set_version(conn, version: int): ...\ndef execute_sql(conn, sql: str): ...\n\n# optional\ndef close_connection(conn): ...\n\n\n\n# migrations/config.py\nfrom sqlalchemy import create_engine, text\n\ndef get_connection(db): return create_engine(f\"sqlite+pysqlite:///{db}\")\ndef close_connection(engine): engine.dispose()\n\ndef ensure_meta_table(engine):\n    with engine.begin() as conn:\n        conn.exec_driver_sql(\n            \"CREATE TABLE IF NOT EXISTS _meta (id INTEGER PRIMARY KEY, version INTEGER NOT NULL)\"\n        )\n        row = conn.exec_driver_sql(\"SELECT version FROM _meta WHERE id=1\").fetchone()\n        if row is None: conn.exec_driver_sql(\"INSERT INTO _meta (id, version) VALUES (1, 0)\")\n\ndef get_version(engine):\n    with engine.connect() as conn:\n        row = conn.exec_driver_sql(\"SELECT version FROM _meta WHERE id=1\").fetchone()\n        return int(row[0]) if row else 0\n\ndef set_version(engine, version: int):\n    with engine.begin() as conn:\n        conn.exec_driver_sql(\"DELETE FROM _meta WHERE id=1\")\n        conn.exec_driver_sql(\"INSERT INTO _meta (id, version) VALUES (1, ?)\", (int(version),))\n\ndef execute_sql(engine, sql: str):\n    with engine.begin() as conn:\n        # Basic split; feel free to use something more robust for your DB\n        for stmt in [s.strip() for s in sql.split(\";\") if s.strip()]: conn.exec_driver_sql(stmt)\n\n\n\nEach function may be sync or async. If any hook returns an awaitable, fastmigrate automatically awaits it so adapters can be built on asyncpg, SQLAlchemy asyncio, psycopg3 async mode, etc.\n\n\n\n\nWhen you run fastmigrate, it will look for migration scripts in ./migrations/ and a database at ./data/database.db. These values can also be overridden by CLI arguments or by values set in the .fastmigrate configuration file, which is in ini format. But you can also provide them as with the command line arguments --db and --migrations.\nHere are some commands:\n\nCreate Database:\nfastmigrate_create_db --db /path/to/data.db\nIf no database is there, create an empty database with version=0. If a versioned db is there, do nothing. If an unversioned db or anything else is there, exit with an error code. This is equivalent to calling fastmigrate.create_db()\nCheck a db\nfastmigrate_check_version --db /path/to/data.db\nThis will report the version of both fastmigrate and the db.\nBackup a db:\nfastmigrate_backup_db --db /path/to/data.db\nBackup the database with a timestamped filename ending with a .backup extention. This is equivalent to calling fastmigrate.backup_db()\nRun migrations:\nfastmigrate_run_migrations --db path/to/data.db --verbose\nRun all needed migrations on the db. Fails if a migration fails, or if there is no managed db at the path. This is equivalent to calling fastmigrate.run_migrations(). Use --verbose to enable debug-level logs.\nEnroll an existing db:\nfastmigrate_enroll_db --db path/to/data.db\nEnroll an existing SQLite database for versioning, adding a default initial migration called 0001-initial.sql, then running it. Running the initial migration will set the version to 1. This is equivalent to calling fastmigrate.enroll_db()\n\n\n\n\nFastMigrate needs to manage database versioning in order to run migrations.\nSo if you already have a database which was created outside of fastmigrate, then you need to enroll it.\nPlease see the dedicated note on enrolling an existing db.\n\n\n\n\nUnversioned Databases: FastMigrate will refuse to run migrations on existing databases that don’t have a _meta table with version information.\nSequential Execution: Migrations are executed in order based on their index numbers. If migration #3 fails, migrations #1-2 remain applied and the process stops.\nVersion Integrity: The database version is only updated after a migration is successfully completed.\nExternal Side Effects: Python and Shell scripts may have side effects outside the database (file operations, network calls) that are not managed by fastmigrate.\nDatabase Locking: During migration, the database may be locked. Applications should not attempt to access it while migrations are running.\nBackups: For safety, you can use the --backup option to create a backup before running migrations.\n\n\n\n\nTo contribute to fastmigrate, create an editable install with the dev dependency group using your favorite package manager.\nFor example, with uv (preferred):\nuv sync\nor with pip 25.1:\npip install -e . --group dev"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "fastmigrate",
    "section": "",
    "text": "fastmigrate is available to install from pypi.\npip install fastmigrate\n\n# or if using uv add it to your pyproject.toml\nuv add fastmigrate\nFastmigrate itself does not require the external sqlite3 command-line tool. If you choose to write .sh migrations that invoke sqlite3 yourself, you’ll need it installed, but .sql migrations run via Python’s built-in sqlite3."
  },
  {
    "objectID": "index.html#how-to-use-fastmigrate-in-your-app",
    "href": "index.html#how-to-use-fastmigrate-in-your-app",
    "title": "fastmigrate",
    "section": "",
    "text": "Once you have added a migrations/ directory to your app, you would typically use fastmigrate in your application code like so:\nfrom fastmigrate import create_db, run_migrations, setup_logging\n\n# At application startup:\ndb_path = \"path/to/database.db\"\nmigrations_dir = \"path/to/migrations\"\n\n# Create/verify there is a versioned database\ncurrent_version = create_db(db_path)\n\n# Optional: enable debug logs from fastmigrate\nsetup_logging(verbose=True)\n\n# Apply any pending migrations\nif not run_migrations(db_path, migrations_dir):\n    print(\"Database migration failed!\")\nThis will create a db if needed. Then, fastmigrate will detect every validly-named migration script in the migrations directory, select the ones with version numbers greater than the current db version number, and run the migration in alphabetical order, updating the db’s version number as it proceeds, stopping if any migration fails.\nThis will guarantee that all subsequent code will encounter a database at the schema version defined by your highest-numbered migration script. So when you deploy updates to your app, those updates should include any new migration scripts along with modifications to code, which should now expect the new db schema.\nIf you get the idea and are just looking for a reminder about a reasonable workflow for safely adding a new migration please see this note on safely adding migrations"
  },
  {
    "objectID": "index.html#key-concepts",
    "href": "index.html#key-concepts",
    "title": "fastmigrate",
    "section": "",
    "text": "Fastmigrate implements the standard database migration pattern, so these key concepts may be familiar.\n\nthe version number of a database:\n\nthis is an int value stored in a single-row table _meta in the field version. This is “db version”, which is also the version of the last migration script which was run on that database.\n\nthe migrations directory contains the migration scripts, which initialize the db to its initial version 1 and update it to the latest version as needed.\nevery valid migration script must:\n\nconform to the “fastmigrate naming rule”\nbe one of the following:\n\na .py or .sh file. In this case, fastmigrate will execute the file, pass the path to the db as the first positional argument. Fastmigrate will interpret a non-zero exit code as failure.\na .sql file. In this case, fastmigrate will execute the SQL script against the database.\n\nterminate with an exit code of 0, if and only if it succeeds\n(ideally) leave the db unmodified, if it fails\n\nthe fastmigrate naming rule is that every migration script match this naming pattern: [index]-[description].[fileExtension], where [index] must be a string representing 4-digit integer. This naming convention defines the order in which scripts will run and the db version each migration script produces.\nattempting a migration is:\n\ndetermining the current version of a database\ndetermining if there are any migration scripts with versions higher than the db version\ntrying to run those scripts\n\n\nWhen Fastmigrate encounters an error, it stops. It does not attempt to roll back or reverse. Therefore, if you want to ensure your migrations are never left half-completed mid-script, add appropriate transactions inside your sql."
  },
  {
    "objectID": "index.html#using-fastmigrate-with-non-sqlite-databases",
    "href": "index.html#using-fastmigrate-with-non-sqlite-databases",
    "title": "fastmigrate",
    "section": "",
    "text": "Fastmigrate is SQLite-first by default, but you can make it database-independent by providing a backend adapter at:\n&lt;your migrations dir&gt;/config.py\nWhen this file exists, :func:fastmigrate.run_migrations will:\n\nload this module dynamically\ncall your adapter hooks to:\n\ncreate the _meta table (if needed)\nread/update the version number\nexecute .sql migrations using your database driver\n\nstill run .py and .sh migrations the same way as usual (passing str(db) as the first positional argument)\n\n\n\nEach hook may be sync or async. If a hook returns an awaitable/coroutine, fastmigrate will automatically await it.\ndef get_connection(db): ...\ndef ensure_meta_table(conn): ...\ndef get_version(conn) -&gt; int: ...\ndef set_version(conn, version: int): ...\ndef execute_sql(conn, sql: str): ...\n\n# optional\ndef close_connection(conn): ...\n\n\n\n# migrations/config.py\nfrom sqlalchemy import create_engine, text\n\ndef get_connection(db): return create_engine(f\"sqlite+pysqlite:///{db}\")\ndef close_connection(engine): engine.dispose()\n\ndef ensure_meta_table(engine):\n    with engine.begin() as conn:\n        conn.exec_driver_sql(\n            \"CREATE TABLE IF NOT EXISTS _meta (id INTEGER PRIMARY KEY, version INTEGER NOT NULL)\"\n        )\n        row = conn.exec_driver_sql(\"SELECT version FROM _meta WHERE id=1\").fetchone()\n        if row is None: conn.exec_driver_sql(\"INSERT INTO _meta (id, version) VALUES (1, 0)\")\n\ndef get_version(engine):\n    with engine.connect() as conn:\n        row = conn.exec_driver_sql(\"SELECT version FROM _meta WHERE id=1\").fetchone()\n        return int(row[0]) if row else 0\n\ndef set_version(engine, version: int):\n    with engine.begin() as conn:\n        conn.exec_driver_sql(\"DELETE FROM _meta WHERE id=1\")\n        conn.exec_driver_sql(\"INSERT INTO _meta (id, version) VALUES (1, ?)\", (int(version),))\n\ndef execute_sql(engine, sql: str):\n    with engine.begin() as conn:\n        # Basic split; feel free to use something more robust for your DB\n        for stmt in [s.strip() for s in sql.split(\";\") if s.strip()]: conn.exec_driver_sql(stmt)\n\n\n\nEach function may be sync or async. If any hook returns an awaitable, fastmigrate automatically awaits it so adapters can be built on asyncpg, SQLAlchemy asyncio, psycopg3 async mode, etc."
  },
  {
    "objectID": "index.html#how-to-use-fastmigrate-from-the-command-line",
    "href": "index.html#how-to-use-fastmigrate-from-the-command-line",
    "title": "fastmigrate",
    "section": "",
    "text": "When you run fastmigrate, it will look for migration scripts in ./migrations/ and a database at ./data/database.db. These values can also be overridden by CLI arguments or by values set in the .fastmigrate configuration file, which is in ini format. But you can also provide them as with the command line arguments --db and --migrations.\nHere are some commands:\n\nCreate Database:\nfastmigrate_create_db --db /path/to/data.db\nIf no database is there, create an empty database with version=0. If a versioned db is there, do nothing. If an unversioned db or anything else is there, exit with an error code. This is equivalent to calling fastmigrate.create_db()\nCheck a db\nfastmigrate_check_version --db /path/to/data.db\nThis will report the version of both fastmigrate and the db.\nBackup a db:\nfastmigrate_backup_db --db /path/to/data.db\nBackup the database with a timestamped filename ending with a .backup extention. This is equivalent to calling fastmigrate.backup_db()\nRun migrations:\nfastmigrate_run_migrations --db path/to/data.db --verbose\nRun all needed migrations on the db. Fails if a migration fails, or if there is no managed db at the path. This is equivalent to calling fastmigrate.run_migrations(). Use --verbose to enable debug-level logs.\nEnroll an existing db:\nfastmigrate_enroll_db --db path/to/data.db\nEnroll an existing SQLite database for versioning, adding a default initial migration called 0001-initial.sql, then running it. Running the initial migration will set the version to 1. This is equivalent to calling fastmigrate.enroll_db()"
  },
  {
    "objectID": "index.html#how-to-enroll-an-existing-unversioned-database-into-fastmigrate",
    "href": "index.html#how-to-enroll-an-existing-unversioned-database-into-fastmigrate",
    "title": "fastmigrate",
    "section": "",
    "text": "FastMigrate needs to manage database versioning in order to run migrations.\nSo if you already have a database which was created outside of fastmigrate, then you need to enroll it.\nPlease see the dedicated note on enrolling an existing db."
  },
  {
    "objectID": "index.html#miscellaneous-considerations",
    "href": "index.html#miscellaneous-considerations",
    "title": "fastmigrate",
    "section": "",
    "text": "Unversioned Databases: FastMigrate will refuse to run migrations on existing databases that don’t have a _meta table with version information.\nSequential Execution: Migrations are executed in order based on their index numbers. If migration #3 fails, migrations #1-2 remain applied and the process stops.\nVersion Integrity: The database version is only updated after a migration is successfully completed.\nExternal Side Effects: Python and Shell scripts may have side effects outside the database (file operations, network calls) that are not managed by fastmigrate.\nDatabase Locking: During migration, the database may be locked. Applications should not attempt to access it while migrations are running.\nBackups: For safety, you can use the --backup option to create a backup before running migrations."
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "fastmigrate",
    "section": "",
    "text": "To contribute to fastmigrate, create an editable install with the dev dependency group using your favorite package manager.\nFor example, with uv (preferred):\nuv sync\nor with pip 25.1:\npip install -e . --group dev"
  },
  {
    "objectID": "custom_backends.html",
    "href": "custom_backends.html",
    "title": "Custom database backends",
    "section": "",
    "text": "Fastmigrate is SQLite-first by default.\nIf you want to use fastmigrate’s migration-runner with another database driver (asyncpg, psycopg3, SQLAlchemy, DuckDB, etc.), you can provide a tiny backend adapter in your migrations directory:\nWhen this file exists, fastmigrate.run_migrations() will delegate the DB-specific operations to it:\n.py and .sh migrations are executed as separate processes as usual, with str(db) passed as the first positional argument.",
    "crumbs": [
      "Custom database backends"
    ]
  },
  {
    "objectID": "custom_backends.html#minimal-required-functions",
    "href": "custom_backends.html#minimal-required-functions",
    "title": "Custom database backends",
    "section": "Minimal required functions",
    "text": "Minimal required functions\nYour migrations/config.py must define the following functions. Each function may be sync or async. If a function returns an awaitable, fastmigrate automatically awaits it.\ndef get_connection(db):\n    \"\"\"Return any handle you want fastmigrate to pass around (engine, pool, etc).\"\"\"\n\ndef ensure_meta_table(conn):\n    \"\"\"Create the _meta table (and an initial version row) if missing.\"\"\"\n\ndef get_version(conn) -&gt; int:\n    \"\"\"Return the current version from _meta.\"\"\"\n\ndef set_version(conn, version: int):\n    \"\"\"Persist the schema version in _meta.\"\"\"\n\ndef execute_sql(conn, sql: str):\n    \"\"\"Execute a SQL migration.\n\n    Return True/None on success; return False or raise on failure.\n    \"\"\"\n\n# optional\ndef close_connection(conn):\n    \"\"\"Dispose/close the handle returned by get_connection.\"\"\"",
    "crumbs": [
      "Custom database backends"
    ]
  },
  {
    "objectID": "custom_backends.html#example-sqlalchemy-adapter-sqlite",
    "href": "custom_backends.html#example-sqlalchemy-adapter-sqlite",
    "title": "Custom database backends",
    "section": "Example: SQLAlchemy adapter (SQLite)",
    "text": "Example: SQLAlchemy adapter (SQLite)\nfrom sqlalchemy import create_engine\n\ndef get_connection(db):\n    return create_engine(f\"sqlite+pysqlite:///{db}\")\n\ndef close_connection(engine):\n    engine.dispose()\n\ndef ensure_meta_table(engine):\n    with engine.begin() as conn:\n        conn.exec_driver_sql(\n            \"CREATE TABLE IF NOT EXISTS _meta (id INTEGER PRIMARY KEY, version INTEGER NOT NULL)\"\n        )\n        row = conn.exec_driver_sql(\"SELECT version FROM _meta WHERE id=1\").fetchone()\n        if row is None:\n            conn.exec_driver_sql(\"INSERT INTO _meta (id, version) VALUES (1, 0)\")\n\ndef get_version(engine):\n    with engine.connect() as conn:\n        row = conn.exec_driver_sql(\"SELECT version FROM _meta WHERE id=1\").fetchone()\n        return int(row[0]) if row else 0\n\ndef set_version(engine, version: int):\n    with engine.begin() as conn:\n        conn.exec_driver_sql(\"DELETE FROM _meta WHERE id=1\")\n        conn.exec_driver_sql(\"INSERT INTO _meta (id, version) VALUES (1, ?)\", (int(version),))\n\ndef execute_sql(engine, sql: str):\n    with engine.begin() as conn:\n        # This split is intentionally simple; use a more robust approach if needed.\n        for stmt in [s.strip() for s in sql.split(\";\") if s.strip()]:\n            conn.exec_driver_sql(stmt)",
    "crumbs": [
      "Custom database backends"
    ]
  }
]